---
description: Guidelines for executing upkep tasks with focus on simplicity, user value, and comprehensive testing
globs: scripts/**/*.sh, tests/**/*.sh, config/**/*
alwaysApply: true
---

## Pre-Implementation Analysis

**Before coding any feature or change:**

- **User Value Check**: Does this solve a real problem for Linux users doing system maintenance?
- **Simplicity First**: Is this the simplest solution that achieves the goal? 
- **Anti-Bloat**: Will this add meaningful value without bloating the codebase?

**If any answer is unclear → stop and reconsider the approach**

## upkep Project Principles

- **Simplicity**: Prefer straightforward solutions over clever ones
- **Maintainability**: Code should be easy to read, understand, and modify  
- **Reliability**: Minimize potential failure points and edge cases
- **User-Focused**: Serve Linux users running personal/development machines
- **Modularity**: Changes should integrate cleanly with existing architecture

## Target User Context

upkep serves Linux users who:
- Run personal/development machines (not enterprise deployments)
- Want automated system maintenance without complexity
- Need occasional debugging/customization capabilities  
- Value reliability over advanced features

## Implementation Standards

### Test-Driven Development (Mandatory)
```bash
# Always follow this pattern:
1. Write tests first (or immediately after coding)
2. Add test files to tests/test_cases/
3. Update tests/test_runner.sh if adding new test files
4. Run full test suite: ./tests/test_runner.sh
```

- **Test Coverage Requirements:**
  - Happy path functionality
  - Error conditions and edge cases
  - Integration with existing components
  - Backward compatibility

### Code Quality Standards
- Follow existing patterns in [scripts/core/](mdc:scripts/core/)
- Add appropriate error handling
- Include helpful comments for complex logic
- Ensure backward compatibility unless explicitly breaking changes needed
- Follow shell scripting best practices from [10-quality/clean-code](mdc:.cursor/rules/10-quality/clean-code.mdc)

## Mandatory Completion Steps

### 1. Test Suite Validation
```bash
# MUST run before considering task complete:
./tests/test_runner.sh
```

**All tests must pass (100% success rate) before task is considered done.**

### 2. Integration Verification
- Test actual user workflow affected by changes
- Verify backward compatibility with existing configurations
- Check error messages are helpful to users
- Validate against existing modules in [scripts/modules/](mdc:scripts/modules/)

### 3. Documentation Updates
Update if changes affect:
- User-facing commands or options
- Configuration format or options  
- Installation or setup procedures
- Error messages or troubleshooting

## Success Criteria Checklist

A task is complete when:

- ✅ **Solves user problem simply and effectively**
- ✅ **Has comprehensive test coverage** 
- ✅ **Passes 100% of test suite**
- ✅ **Maintains or improves code quality**
- ✅ **Integrates seamlessly with existing functionality**
- ✅ **Provides clear value to target users**
- ✅ **Documentation updated as needed**

## Common Anti-Patterns to Avoid

```bash
# ❌ DON'T: Add complex enterprise features
complex_environment_management_with_staging_prod()

# ✅ DO: Add simple, practical features  
UPKEP_DRY_RUN=true upkep run
```

```bash
# ❌ DON'T: Skip testing
implement_feature_without_tests()

# ✅ DO: Test-driven development
write_comprehensive_tests_first()
```

```bash
# ❌ DON'T: Over-engineer solutions
complex_inheritance_pattern_with_abstractions()

# ✅ DO: Keep it simple and functional
simple_function_that_solves_problem()
```

## Key Questions Before Starting

1. **What specific user problem does this solve?**
2. **What is the simplest implementation approach?**
3. **What could go wrong and how do we test for it?**
4. **Does this maintain backward compatibility?**
5. **How will users discover and use this feature?**

**Remember: Better to implement something simple and useful than something complex and complete.**
