# Task ID: 6
# Title: Design Visual Feedback and Styled CLI Output
# Status: in-progress
# Dependencies: 5
# Priority: medium
# Description: Provide rich CLI output with progress indicators, styled summaries, ASCII art branding, and color-coded statuses based on the comprehensive UI Design Document.
# Details:
Implement the Taskmaster-inspired visual design as specified in docs/DESIGN.md, including: terminal-first dark theme with semantic color palette, module overview tables with hierarchical display, execution summary boxes (success/warning/error variants), real-time progress indicators, enhanced ASCII branding and section headers, status icon system, and multi-format output support (human-readable, JSON, YAML). Use tput and ANSI escape codes for color and formatting. Follow the 4-phase implementation roadmap outlined in the design document. Ensure accessibility with colorblind-friendly palettes.

# Test Strategy:
Visual inspection and automated snapshot tests for CLI output. Test accessibility with different terminal themes. Verify implementation against the specifications in docs/DESIGN.md. Test all component variants and output formats.

# Subtasks:
## 1. Implement Core Layout Builder Components [done]
### Dependencies: None
### Description: Develop the four foundational scripts in scripts/core/ (box_builder.sh, layout_loader.sh, width_helpers.py, palette.sh) according to the APIs and behaviors defined in layout_builder_spec.md v1.2, ensuring support for Unicode/ASCII rendering, responsive widths, and centralized color/icon palettes.
### Details:
Ensure each script matches the spec, supports both Unicode and ASCII fallback, and is compatible with Bash 5 and Python stdlib only. Validate that the palette and icon maps are centralized and accessible by the builder.
<info added on 2025-07-30T16:16:09.102Z>
Implementation started with creation of four foundational scripts in scripts/core/ directory following layout_builder_spec.md v1.2. Beginning with palette.sh as the base dependency for other components, implementing centralized color and emoji palettes with colorblind support. Next will implement width_helpers.py for Unicode width calculation using wcwidth, followed by box_builder.sh for DSL primitives and layout_loader.sh for JSON processing and responsive layout algorithms.
</info added on 2025-07-30T16:16:09.102Z>
<info added on 2025-07-30T16:19:19.470Z>
All four foundational scripts successfully implemented and completed in scripts/core/ directory. palette.sh provides centralized color and emoji palettes with 16-status mapping, colorblind support, and WCAG-AA compliance. width_helpers.py handles Unicode width calculation using Python stdlib unicodedata for emoji, combining characters, and multi-byte sequences. box_builder.sh implements DSL primitives (box_new, row_new, box_render, row_add_cell, box_add_row) with Unicode/ASCII fallback and border styles. layout_loader.sh provides JSON processing pipeline with responsive layout algorithms, SIGWINCH trapping, and width caching. All scripts conform to layout_builder_spec.md v1.2 specifications. Ready for testing phase to validate API behavior and rendering accuracy.
</info added on 2025-07-30T16:19:19.470Z>
<info added on 2025-07-30T16:26:18.492Z>
SUCCESS: All four foundational scripts successfully implemented and tested! Completed Components: palette.sh (centralized color and emoji palettes with comprehensive 16-status mapping, colorblind support, and WCAG-AA compliance), width_helpers.py (Unicode width calculation using unicodedata Python std-lib only, supporting emoji, combining characters, and multi-byte sequences), box_builder.sh (DSL primitives with Unicode/ASCII fallback and border styles), layout_loader.sh (JSON processing pipeline with responsive layout algorithms, SIGWINCH trapping, and width caching). Test Results: All components verified working - palette system emoji and color retrieval, width helpers Unicode width calculation and text fitting, box builder DSL primitives and token creation, layout loader JSON processing and box creation, box rendering with borders. Key Features Implemented: Unicode/ASCII fallback support via UPKEP_ASCII environment variable, colorblind-friendly palettes via UPKEP_COLORBLIND environment variable, responsive layout with minimum 80-column enforcement, SIGWINCH trapping for terminal resize handling, Python std-lib only dependency for width calculation, comprehensive 16-status semantic mapping system. All components follow layout_builder_spec.md v1.2 specifications and are ready for integration with the legacy bridge system.
</info added on 2025-07-30T16:26:18.492Z>

## 2. Bridge Legacy Formatter to Layout Builder [pending]
### Dependencies: 6.1
### Description: Create a compatibility layer in utils.sh so that legacy create_box() and related calls proxy to the new Layout Builder, emitting deprecation warnings and ensuring seamless transition.
### Details:
Implement proxy logic and deprecation warnings. Maintain temporary support for legacy call-sites while refactoring proceeds.

## 3. Integrate Real-Time Progress Indicators and Status Icons [pending]
### Dependencies: 6.1
### Description: Re-implement spinner and progress-bar components to render within Layout Builder boxes, supporting in-place updates (TTY), static dots (no-TTY), nested steps, and color/emoji status icons sourced from the centralized palette.
### Details:
Ensure progress indicators and status icons are fully integrated, support both Unicode and ASCII modes, and honor colorblind-friendly palettes.

## 4. Enable Multi-Format and Accessible Output [pending]
### Dependencies: 6.1
### Description: Implement machine-readable output modes (--output json|yaml), ensure helpers render_json and render_yaml pretty-print the same data structure as the builder, and finalize colorblind-friendly palettes with WCAG-AA contrast compliance.
### Details:
Support toggling palettes by flag or config, and provide ASCII fallback when UPKEP_ASCII=1 or locale is non-UTF-8. Validate output structure and accessibility.

## 5. Refactor Legacy Call-Sites and Update Documentation [pending]
### Dependencies: 6.2, 6.3, 6.4
### Description: Refactor all legacy formatter call-sites to use JSON descriptors for the Layout Builder, update README, STYLING_SYSTEM_GUIDE.md, and templates, and ensure all tests and demos pass with the new system.
### Details:
Remove all lingering references to the component-string formatter, update documentation and examples, and ensure full regression QA with existing and new tests.

## 6. Create box_builder.sh with DSL primitives [done]
### Dependencies: None
### Description: Implement the core DSL primitives (box_new, row_new, box_render, row_add_cell, box_add_row) and helper functions (make_text, make_emoji, make_color, fit_cell) as specified in layout_builder_spec.md §4
### Details:
Create scripts/core/box_builder.sh with:
- DSL primitives: box_new, row_new, box_render, row_add_cell, box_add_row
- Token helpers: make_text, make_emoji, make_color (with reset emitting ANSI 0)
- Cell fitting: fit_cell for wrap/ellipsis overflow
- Border styles: major, minor, emphasis with Unicode/ASCII fallback
- Width calculation integration with width_helpers.py

## 7. Create layout_loader.sh with JSON processing [done]
### Dependencies: None
### Description: Implement JSON → tokens → builder pipeline with width caching, SIGWINCH trapping, and responsive layout algorithms as specified in layout_builder_spec.md §3
### Details:
Create scripts/core/layout_loader.sh with:
- JSON descriptor parsing and validation
- Terminal width caching with SIGWINCH trap
- Column sizing algorithm (natural width → proportional distribution)
- Overflow handling (wrap vs ellipsis)
- Minimum 80-column enforcement
- Integration with box_builder.sh DSL

## 8. Create width_helpers.py for Unicode width calculation [done]
### Dependencies: None
### Description: Implement wcwidth-based display width helper for accurate Unicode character width calculation, supporting emoji and multi-byte characters
### Details:
Create scripts/core/width_helpers.py with:
- wcwidth integration for accurate Unicode width calculation
- Support for emoji, combining characters, and multi-byte sequences
- Python std-lib only (no external dependencies)
- Integration with layout_loader.sh for column sizing
- Test coverage for edge cases (zero-width, double-width characters)

## 9. Create palette.sh with centralized color and emoji maps [done]
### Dependencies: None
### Description: Implement centralized semantic color and emoji palettes with colorblind-friendly alternatives, supporting runtime palette switching via environment variables
### Details:
Create scripts/core/palette.sh with:
- EMOJI_MAP_DEFAULT and EMOJI_MAP_CB (colorblind) arrays
- COLOR_MAP_DEFAULT and COLOR_MAP_CB arrays with semantic mappings
- choose_palette() function for runtime palette selection
- Support for UPKEP_COLORBLIND environment variable
- Integration with STATUS_ICONS from existing system
- WCAG-AA contrast compliance (≥ 4.5:1 ratio)

## 10. Implement legacy bridge in utils.sh [done]
### Dependencies: None
### Description: Create compatibility layer in utils.sh so legacy create_box() and related calls proxy to the new Layout Builder with deprecation warnings
### Details:
Modify scripts/modules/core/utils.sh to:
- Proxy create_box() and create_summary_box() to new Layout Builder
- Emit deprecation warnings for legacy calls
- Maintain temporary compatibility until v3.1
- Preserve existing BOX_* glyph variables for drop-in compatibility
- Ensure seamless transition for existing scripts

## 11. Re-implement progress indicators for Layout Builder [done]
### Dependencies: None
### Description: Update spinner and progress-bar components to render inside Layout Builder boxes with proper Unicode/ASCII support and quiet mode handling
### Details:
Update progress indicator implementation to:
- Render spinners and progress bars inside Layout Builder boxes
- Support Braille spinner frames (⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏) at 100ms cadence
- Provide ASCII fallback (~) for colorblind mode
- Implement 50-cell progress bars (█/░) with style inheritance
- Handle quiet/no-TTY mode with static dots
- Ensure cursor visibility and proper cleanup

## 12. Create comprehensive Bats test suite [pending]
### Dependencies: None
### Description: Implement acceptance tests covering emoji-width alignment, color-bleed prevention, wrapping vs ellipsis, SIGWINCH resize handling, spinner cadence, ASCII mode, and palette toggle functionality
### Details:
Create tests/layout_*.bats with test cases:
- emoji_width: Icons align in 3-row table
- color_bleed: Reset after each cell; borders remain default color
- wrap_vs_ellipsis: Cell overflow obeys descriptor
- composite_mixed: Color switches inside composite cells
- sigwinch_resize: Re-render widths 80 → 120
- spinner_cadence: 10 frames ≈ 1s (100ms each)
- ascii_mode: Render using ASCII fallback
- palette_toggle: Render twice with CB env-var flip

## 13. Refactor legacy formatter call-sites to JSON descriptors [pending]
### Dependencies: None
### Description: Update all existing formatter call-sites throughout the codebase to use JSON descriptors for the Layout Builder instead of legacy component-string formatting
### Details:
Refactor all legacy formatter usage to:
- Replace draw_box, create_status_line, create_box calls with JSON descriptors
- Update module overview tables to use Layout Builder JSON format
- Convert execution summary boxes to JSON-driven rendering
- Update ASCII art and branding components
- Ensure all visual components use the new builder system
- Maintain temporary proxy compatibility during transition

## 14. Tag repository v0.2.0-pre-refactor [pending]
### Dependencies: None
### Description: Create git tag v0.2.0-pre-refactor before the first commit touching legacy formatter code to mark the pre-refactor state
### Details:
Create git tag to mark the pre-refactor state:
- Tag as v0.2.0-pre-refactor before any legacy code changes
- Document the tag purpose in commit message
- Ensure clean state before beginning Layout Builder migration
- Provide rollback point if needed during refactoring

## 15. Update documentation and examples [pending]
### Dependencies: None
### Description: Update README examples, docs/STYLING_SYSTEM_GUIDE.md, and any templates that embed boxes/tables to reflect the new Layout Builder system
### Details:
Update documentation to reflect Layout Builder:
- Update README.md with new JSON-driven examples
- Revise docs/STYLING_SYSTEM_GUIDE.md for Layout Builder usage
- Update any template files that embed boxes/tables
- Create examples/update_module.sh showing JSON-driven box identical to spec snippet
- Document migration path from legacy formatter
- Update configuration examples and usage patterns

## 16. Implement real-time progress reporter functions [pending]
### Dependencies: None
### Description: Create progress_start, progress_step, progress_end functions that emit in-place updates (TTY) or appended lines (no-TTY), supporting nested steps and STATUS_ICONS integration
### Details:
Implement real-time progress reporting:
- progress_start: Initialize progress context with TTY detection
- progress_step: Emit in-place updates (TTY) or appended lines (no-TTY)
- progress_end: Clean up progress context and restore cursor
- Support nested steps with proper indentation
- Integrate with STATUS_ICONS from palette.sh
- Handle both interactive and non-interactive terminals
- Ensure proper cleanup on interruption
<info added on 2025-07-30T16:11:41.168Z>
Enhanced step-by-step feedback requirements:
- Track and display current step number and total steps
- Show detailed step descriptions with contextual information
- Provide estimated time remaining based on step completion rates
- Display hierarchical progress for nested operations with visual tree structure
- Include percentage completion indicators alongside step counters
- Support custom step labels and descriptions for better user understanding
- Implement progress persistence across interruptions for resumable operations
- Add configurable verbosity levels for different detail requirements
- Integrate with Layout Builder styling system for consistent visual presentation
- Support dynamic step addition/removal during execution
- Provide step timing information and performance metrics
- Include visual separators and grouping for complex multi-phase operations
</info added on 2025-07-30T16:11:41.168Z>

## 17. Port ASCII branding to branding.sh with JSON output [pending]
### Dependencies: None
### Description: Port ascii_art.sh to branding.sh, exposing draw_brand_header and draw_section_header functions that emit JSON consumed by the Layout Builder, honoring UPKEP_ASCII and colorblind palette
### Details:
Create scripts/modules/core/branding.sh with:
- Port existing ASCII art functionality from ascii_art.sh
- draw_brand_header: Emit JSON for upKep branding header
- draw_section_header: Emit JSON for section headers
- Honor UPKEP_ASCII environment variable for ASCII fallback
- Support colorblind palette via palette.sh integration
- Ensure proper Unicode/ASCII rendering compatibility
- Maintain existing ASCII art quality and styling

## 18. Integrate STATUS_ICONS with centralized palette [pending]
### Dependencies: None
### Description: Move existing STATUS_ICONS and STATUS_COLORS maps into palette.sh as the single source of truth, ensuring the Layout Builder consumes unified icon and color definitions
### Details:
Integrate STATUS_ICONS with centralized palette:
- Move STATUS_ICONS and STATUS_COLORS from utils.sh to palette.sh
- Ensure Layout Builder uses unified icon and color definitions
- Maintain backward compatibility with existing STATUS_ICONS usage
- Support both default and colorblind palette variants
- Update all references to use centralized palette system
- Ensure semantic consistency across all visual components
<info added on 2025-07-30T16:11:50.401Z>
Expand implementation to include comprehensive STATUS_ICONS system with complete 16-status mapping (success, failed, warning, pending, running, paused, skip, new, timing, stats, suggestion, action, config, package, cleanup, details) and corresponding STATUS_COLORS mapping with semantic associations (success=green, failed=red, warning=yellow, pending=blue, running=cyan, paused=magenta, skip=white, etc.). Add format_status() function that combines icon, color, and text formatting for unified status display. Ensure the comprehensive mapping provides rich visual feedback for all operation types while maintaining the centralized palette architecture and colorblind accessibility support.
</info added on 2025-07-30T16:11:50.401Z>

## 19. Add machine-readable output support [pending]
### Dependencies: None
### Description: Implement --output json|yaml CLI option with render_json and render_yaml helpers that pretty-print the same data structure passed to the Layout Builder
### Details:
Add machine-readable output support:
- Implement --output json|yaml CLI flag parsing
- Create render_json helper for pretty-printed JSON output
- Create render_yaml helper for pretty-printed YAML output
- Ensure output structure matches data passed to Layout Builder
- Support both human-readable and machine-readable modes
- Maintain consistent data structure across output formats
- Add appropriate content-type headers for machine output

## 20. Finalize colorblind palettes with WCAG-AA compliance [pending]
### Dependencies: None
### Description: Ensure colorblind palettes meet WCAG-AA contrast requirements (≥ 4.5:1 ratio), support palette toggling by flag or persisted config, and create snapshot tests to prove identical structure and safe colors
### Details:
Finalize colorblind accessibility:
- Ensure WCAG-AA contrast ratio ≥ 4.5:1 for all colorblind palette colors
- Support palette toggling via UPKEP_COLORBLIND flag or persisted config
- Create snapshot tests to verify identical structure across palettes
- Validate safe colors for all visual components
- Test palette switching at runtime without restart
- Document accessibility compliance and testing procedures
- Ensure semantic meaning preserved in colorblind mode

## 21. Run comprehensive regression QA and fix edge cases [pending]
### Dependencies: None
### Description: Execute all existing demos and tests (box_drawing_demo.sh, test_modular_system.sh) against the new Layout Builder, patch any residual spacing/emoji/wrap issues, and ensure no TODOs remain
### Details:
Comprehensive regression testing:
- Run box_drawing_demo.sh against new Layout Builder
- Execute test_modular_system.sh with new system
- Fix any residual spacing, emoji, or text wrapping issues
- Ensure all existing visual components work correctly
- Verify no TODOs or incomplete implementations remain
- Test edge cases: very long text, mixed Unicode, terminal resize
- Validate all existing functionality preserved
- Ensure shellcheck and bats tests pass
<info added on 2025-07-30T16:12:03.434Z>
Enhanced regression testing to specifically address visual display generation errors and spacing issues from subtask 6.12:

**Multi-column auto spacing function evaluation**:
- Validate and fix column spacing algorithm in table generation functions
- Test proper alignment across all table components with varying content lengths
- Verify consistent spacing in module overview tables and execution summaries

**Emoji spacing error resolution**:
- Implement robust emoji width calculation for all Unicode emoji characters
- Fix misaligned running, stats, and suggestions rows in test_modular_system.sh output
- Execute test_all_emojis.sh to validate accurate spacing across all emoji types
- Test emoji rendering in progress indicators and status displays

**Box drawing demo issue fixes**:
- Resolve long text wrap problem ensuring borders remain intact while inner text wraps properly
- Fix title overflow issue where box width is determined by the longer of title or content
- Implement proper text wrapping that preserves box border integrity
- Test nested box structures and complex layouts

**Comprehensive edge case validation**:
- Test extremely long text handling in all visual components
- Verify mixed Unicode character support across different terminal environments
- Validate dynamic terminal resize behavior for all layout components
- Test Layout Builder system against all known visual display bugs
- Ensure permanent resolution of spacing and alignment issues through the new architecture
</info added on 2025-07-30T16:12:03.434Z>

## 22. Follow 4-phase implementation roadmap from docs/DESIGN.md [pending]
### Dependencies: None
### Description: Implement the visual feedback system following the 4-phase roadmap outlined in docs/DESIGN.md, ensuring proper sequencing and integration of all Layout Builder components
### Details:
Follow the 4-phase implementation roadmap:
- Phase 1: Core Layout Builder infrastructure (box_builder.sh, layout_loader.sh, width_helpers.py, palette.sh)
- Phase 2: Integration and compatibility layer (legacy bridge, progress indicators, status icons)
- Phase 3: Enhanced features (real-time progress, branding, machine-readable output)
- Phase 4: Quality assurance and documentation (testing, accessibility, documentation updates)
- Ensure proper dependency management and sequencing between phases
- Validate each phase completion before proceeding to next

## 23. Revise Layout Builder to match Rich Visual Examples [pending]
### Dependencies: None
### Description: Fix the current Layout Builder implementation to produce the beautiful, sophisticated visual output shown in the Rich Visual Examples section of DESIGN.md
### Details:
The current Layout Builder implementation produces basic, uninspired output that doesn't match the rich visual design specified in DESIGN.md section 7.5. This subtask will:

1. Fix the box rendering algorithm in box_builder.sh to produce proper Unicode borders
2. Implement proper column alignment and spacing for hierarchical tables
3. Add rich visual formatting for execution summary boxes (success/warning/error variants)
4. Implement proper color integration throughout the rendering pipeline
5. Add support for hierarchical module overview tables with proper indentation
6. Fix Unicode character rendering and width calculation issues
7. Implement proper progress indicators with Unicode characters
8. Add support for ASCII art headers and section dividers
9. Ensure all components match the visual quality shown in the Rich Visual Examples

The goal is to transform the current ugly output (like "+------------" and broken borders) into the beautiful, Taskmaster-quality output shown in the design examples.

